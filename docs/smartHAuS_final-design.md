# Final Design Summary - smartHAuS
intelligent **_H_** ome **_Au_** tomation **_S_** ystem


## Preamble
This is the final systems design for the VTC Senior Project known as smartHAuS (Spring 2009).


## User Interface

Our user interface is going to be a web based GUI. We are using this approach because the ease of generating html and specifically forms. For now the website will be local to the home, but possibility exists to allow access from the internet. 

The main site will be structured similar to configuration utilities provided by routers. There will be different panels, denoted by tabs on the top of the page, each of which responsible for one particular section. The panels aren't set in stone yet, but we plan on having a bare minimum of: 

 1. Main panel 
  - Directs the user to important features 
 2. Connection panel 
  - Allows the user to hookup and verify devices with the system. 
 3. Tagging panel 
  - Gives the user a convenient way to manage tags of devices 
   (Similar to the way delicious and windows vista's picture view can tag things) 
 4. Triggers panel 
  - Allows the user to set up simple scripts between the sensors, devices/tags, and actions. 
 5. Device overview panel 
  - Lets the user view the features of particular devices, and configure them if applicable 
	
Each panel will have a main navigation pane on the left, and a content pane in the center... And if applicable, additional panes on the far right to display context based information. 
   
Each tab will be generated by it's own perl cgi script, which will interface with the system's daemons and settings files to give appropriate displays and control options. The hope is to get it so that the perl script can call other scripts that generate specific parts of the page, aka sub items. The higher level perl scripts will be responsible for layout, and the data will be generated by the lower level ones. This will enable us to code up a layout with "stubs", which can be filled out later. 


## System Architecture


### Architecture Overview
Hardware hooks up to the brain through a device manager, the user interacts with the html. The cgi scripts facilitate the communication between the two.

![alt text][sysarchitecture]

[sysarchitecture]: ./images/system-architecture.png "System Architecture"


### CGI / Web Interface

The CGI is split up into different layers. At the far left is the main site, and it gets broken down eventually into the content generators, which manipulate the data directly. Anything that needs to be displayed to the user must have a content generator. Signals from the user are then routed back down to the appropriate content generator to be handled appropriately. Content generators will need to lock datafiles, because multiple users may be accessing the scripts at one time.

![alt text][cgiconfig]

[cgiconfig]: ./images/cgi-system.png "CGI configuration"


### Device Manager

The device manager manages the device connections and the sending / receiving of signals using the icanHAS protocol. Initially everything runs through the Authenticator, which will wait until the user "authorizes" the device... then it dumps the device facilities to the database, logs the authentication, and lets the device know that its OK to start doing stuff. During authorization, the user can set up access levels for the whole device and override it for individual features. 

Signals from the authenticated devices are sent to scripter. There are some basic scripts that just log the data. Some auto-generated scripts for each output the user can run on command.  

Input and output are queued, and a call-response setup will be in place for verification of sent data. 

![alt text][devicemang]

[devicemang]: ./images/devicemang.png "Device Management Flow"


## Risks 

Functional Brain Hardware 

  - Getting the brain to work on the nslu2 hardware might be difficult. 
  - We'll likely just be using a second hand laptop, which would have better specs, and still small form factor/ low power usage. 

Not strong coders 

  - We've been learning Perl, but some things are still tricky to do. 
  - Individuals who are lacking in Perl, may instead design systems in their choice of language, implementing the icanHAS protocol. 
  - We are planing on using an html template format that is parsed by Perl scripts, so the bulk of the display will be pretty much basic html, which is easy to learn. 
	
Breaking the HCS12 

  - The HCS12 is prone to burning out if not taken care of. 
  - We may need to use some of our funds to get newer models in case ours malfunction. 
  - Many of the external devices can be implemented superficially using a simple computer program. 
	
Implementing our icanHAS protocol 

  - The system teeters on getting this feature working, a functional product depends on this. 
  - To mitigate, this will be the focus of a lot of our work until we feel that it is going to be successful.
